/*
 * This source file was generated by the Gradle 'init' task
 */
package scratchgame;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import config.Config;
import config.ConfigLoader;
import model.BonusSymbol;
import model.StandardSymbol;
import model.WinCombination;
import picocli.CommandLine;
import picocli.CommandLine.Command;
import picocli.CommandLine.Option;

@Command(name = "ScratchGame", version = "1.0", mixinStandardHelpOptions = true,
        description = "Scratch game with specified configuration and betting amount.")
public class App implements Runnable {

    @Option(names = "--config", description = "Path to the configuration file", required = true)
    private String configFilePath;

    @Option(names = "--betting-amount", description = "Amount to bet", required = true)
    private Double bettingAmount;

    private Config config;

    private MatrixGenerator matrixGenerator;

    // Default constructor needed by picocli
    public App() {
        this.matrixGenerator = null; 
    }


    public void setConfig(Config config) {
        this.config = config;
    }
        
    public void setMatrixGenerator(MatrixGenerator matrixGenerator) {
        this.matrixGenerator = matrixGenerator;
    }
    
    @Override
    public void run() {
        try {
            // Load config and initialize game
            this.config = ConfigLoader.loadConfig(configFilePath);
            this.matrixGenerator = new MatrixGenerator(config);
    
            // Generate game result
            GameResult result = play(bettingAmount);
    
            // Create custom JSON writer for exact formatting
            String jsonResult = formatGameResultAsJson(result);
            System.out.println(jsonResult);
    
        } catch (CommandLine.ParameterException e) {
            System.err.println("Parameter error: " + e.getMessage());
            CommandLine.usage(this, System.err);
        } catch (IOException e) {
            System.err.println("Error: " + e.getMessage());
        }
    }

    private String formatGameResultAsJson(GameResult result) {
        StringBuilder sb = new StringBuilder();
        sb.append("{\n");
        
        // Format matrix
        sb.append("    \"matrix\": [\n");
        for (int i = 0; i < result.getMatrix().length; i++) {
            sb.append("        [\"")
              .append(String.join("\", \"", result.getMatrix()[i]))
              .append("\"]");
            if (i < result.getMatrix().length - 1) sb.append(",");
            sb.append("\n");
        }
        sb.append("    ],\n");
        
        // Format reward (as integer if whole number)
        double reward = result.getReward();
        sb.append("    \"reward\": ")
          .append(reward == (int)reward ? (int)reward : reward)
          .append(",\n");
        
        // Format winning combinations
        sb.append("    \"applied_winning_combinations\": {\n");
        Map<String, List<String>> combinations = result.getAppliedWinningCombinations();
        if (combinations != null && !combinations.isEmpty()) {
            int count = 0;
            for (Map.Entry<String, List<String>> entry : combinations.entrySet()) {
                sb.append("        \"")
                  .append(entry.getKey())
                  .append("\": [\"")
                  .append(String.join("\", \"", entry.getValue()))
                  .append("\"]");
                if (++count < combinations.size()) sb.append(",");
                sb.append("\n");
            }
        }
        sb.append("    },\n");
        
        // Format bonus symbol
        // Note: This is a list of applied bonus symbols
        List<String> bonusSymbols = result.getAppliedBonusSymbols();
        sb.append("    \"applied_bonus_symbol\": ")
          .append(bonusSymbols != null && !bonusSymbols.isEmpty() ? "[\"" + String.join("\", \"", bonusSymbols) + "\"]" : "null")
          .append("\n");

        // Select display bonus (highest value non-MISS, or first MISS if no others)
        // appliedBonusSymbol = allBonusSymbols.stream()
        // .filter(s -> !"MISS".equals(s))
        // .max(Comparator.comparing(s -> {
        //     BonusSymbol b = (BonusSymbol) config.getSymbols().get(s);
        //     return b.getImpact().equals("multiply_reward") 
        //         ? b.getRewardMultiplier() 
        //         : b.getExtra();
        // }))
        // .orElse(allBonusSymbols.isEmpty() ? null : allBonusSymbols.get(0));
        sb.append("}");
        return sb.toString();
    }

    public GameResult play(double betAmount) {
        String[][] matrix = matrixGenerator.generateMatrix();
        GameResult result = calculateReward(matrix, betAmount, config);
        result.setMatrix(matrix);
        return result;
    }
    
    private GameResult calculateReward(String[][] matrix, double betAmount, Config config) {
        double totalReward = 0;
        Map<String, List<String>> appliedWinningCombinations = new HashMap<>();
        List<String> appliedBonusSymbols = new ArrayList<>();
        boolean hasWinningCombination = false;
    
        // 1. Count symbols and record positions
        Map<String, Integer> symbolCounts = new HashMap<>();
        Map<String, List<int[]>> symbolPositions = new HashMap<>();
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                String symbol = matrix[i][j];
                symbolCounts.merge(symbol, 1, Integer::sum);
                symbolPositions.computeIfAbsent(symbol, k -> new ArrayList<>()).add(new int[]{i, j});
            }
        }
    
        // 2. Find all winning combinations
        Map<String, List<WinCombination>> symbolWins = new HashMap<>();
    
        // Process same_symbol wins (highest count only)
        for (Map.Entry<String, Integer> entry : symbolCounts.entrySet()) {
            String symbol = entry.getKey();
            int count = entry.getValue();
            
            if (config.getSymbols().containsKey(symbol) && 
                config.getSymbols().get(symbol) instanceof StandardSymbol) {
                
                WinCombination bestSameSymbol = null;
                for (WinCombination wc : config.getWinCombinations().values()) {
                    if (wc.getWhen().equals("same_symbols") && 
                        wc.getCount() <= count &&
                        (bestSameSymbol == null || wc.getCount() > bestSameSymbol.getCount())) {
                        bestSameSymbol = wc;
                    }
                }
                
                if (bestSameSymbol != null) {
                    symbolWins.computeIfAbsent(symbol, k -> new ArrayList<>()).add(bestSameSymbol);
                    hasWinningCombination = true;
                }
            }
        }
    
        // Process linear wins using the exact patterns from config
        for (WinCombination wc : config.getWinCombinations().values()) {
            if (wc.getWhen().equals("linear_symbols")) {
                for (List<String> area : wc.getCoveredAreas()) {
                    // Get first cell's symbol
                    String[] firstCell = area.get(0).split(":");
                    int row = Integer.parseInt(firstCell[0]);
                    int col = Integer.parseInt(firstCell[1]);
                    String symbol = matrix[row][col];
                    
                    if (!(config.getSymbols().get(symbol) instanceof StandardSymbol)) {
                        continue;
                    }
    
                    // Check if all cells in area have same symbol
                    boolean isWin = true;
                    for (String cell : area) {
                        String[] coords = cell.split(":");
                        int r = Integer.parseInt(coords[0]);
                        int c = Integer.parseInt(coords[1]);
                        if (!matrix[r][c].equals(symbol)) {
                            isWin = false;
                            break;
                        }
                    }
    
                    if (isWin) {
                        symbolWins.computeIfAbsent(symbol, k -> new ArrayList<>()).add(wc);
                        hasWinningCombination = true;
                    }
                }
            }
        }
    
        // 3. Calculate rewards with ALL multipliers
        if (hasWinningCombination) {
            for (Map.Entry<String, List<WinCombination>> entry : symbolWins.entrySet()) {
                String symbol = entry.getKey();
                StandardSymbol stdSymbol = (StandardSymbol) config.getSymbols().get(symbol);
                double symbolReward = betAmount * stdSymbol.getRewardMultiplier();
                
                List<String> combinationNames = new ArrayList<>();
                for (WinCombination wc : entry.getValue()) {
                    symbolReward *= wc.getRewardMultiplier();
                    combinationNames.add(wc.getName());
                }
                
                appliedWinningCombinations.put(symbol, combinationNames);
                totalReward += symbolReward;
            }
    
            // 4. Process bonus symbols
            double bonusMultiplier = 1.0;
            double bonusAddition = 0.0;
            
            for (String[] row : matrix) {
                for (String symbol : row) {
                    if (config.getSymbols().containsKey(symbol) && 
                        config.getSymbols().get(symbol) instanceof BonusSymbol) {
                        BonusSymbol bonus = (BonusSymbol) config.getSymbols().get(symbol);
                        appliedBonusSymbols.add(symbol);
                        
                        switch (bonus.getImpact()) {
                            case "multiply_reward" -> bonusMultiplier *= bonus.getRewardMultiplier();
                            case "extra_bonus" -> bonusAddition += bonus.getExtra();
                            case "miss" -> {
                                appliedBonusSymbols.remove(symbol);
                            }
                        }
                    }
                }
            }
            
            totalReward = totalReward * bonusMultiplier + bonusAddition;
        }
    
        return new GameResult(matrix, totalReward, appliedWinningCombinations, appliedBonusSymbols);
    }
    
    public static void main(String[] args) {
        int exitCode = new CommandLine(new App()).execute(args);
        System.exit(exitCode);
    }
}